# 2020 M6W5 ARTS

# 1. Algorithm

上周开始学习并发编程，因此找了多线程的问题来练习，巩固知识。

#### [1114. 按序打印](https://leetcode-cn.com/problems/print-in-order/)

```
我们提供了一个类：

public class Foo {
  public void one() { print("one"); }
  public void two() { print("two"); }
  public void three() { print("three"); }
}
三个不同的线程将会共用一个 Foo 实例。

线程 A 将会调用 one() 方法
线程 B 将会调用 two() 方法
线程 C 将会调用 three() 方法
请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。

 

示例 1:

输入: [1,2,3]
输出: "onetwothree"
解释: 
有三个线程会被异步启动。
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。
正确的输出是 "onetwothree"。
示例 2:

输入: [1,3,2]
输出: "onetwothree"
解释: 
输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。
正确的输出是 "onetwothree"。
 

注意:

尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。

你看到的输入格式主要是为了确保测试的全面性。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/print-in-order
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

使用Lock和Condtion

```java
class Foo {

    final Lock lock = new ReentrantLock();
    final Condition first = lock.newCondition();
    final Condition second = lock.newCondition();
    private  AtomicInteger flag = new AtomicInteger(1);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        lock.lock();
        try {
            // printFirst.run() outputs "first". Do not change or remove this line.
            printFirst.run();
            flag.set(2);           
            first.signal();
        } finally {
            lock.unlock();
        }

    }

    public void second(Runnable printSecond) throws InterruptedException {
        lock.lock();
        try {
            while(flag.get() != 2) {
                first.await();
            }
            // printSecond.run() outputs "second". Do not change or remove this line.
            printSecond.run();
            flag.set(3);           
            second.signal();
        } finally {
            lock.unlock();
        }        
    }

    public void third(Runnable printThird) throws InterruptedException {
        lock.lock();
        try {
            while(flag.get() != 3) {
                second.await();
            }
            // printThird.run() outputs "third". Do not change or remove this line.
            printThird.run();
        } finally {
            lock.unlock();
        }               
    }
}
```





# 2. Review

# 3. Tip

## 3.1 在构造方法中抛出异常

我们会遇到一些情况当创建对象时需要检查参数有效性，比如：

```java
public class Person {
  private int age;
  public Person(int _age) {
    if (_age < 0) {
      throw new Exception();
    }
    this.age = _age;
  }
}
```

那么在构造方法中抛出异常是一个好办法么？

参考： https://stackoverflow.com/questions/6086334/is-it-good-practice-to-make-the-constructor-throw-an-exception

## 3.2 预测试提交、个人构建、试飞构建

这是CI/CD中的概念，预测试提交(pre-tested commit)、个人构建(personal build)、试飞构建(preflight build)其实讲的是同一件事，就是本地提交会自动测试是否构建通过，如果通过了持续集成服务器才会将变更提交到版本控制库中。

Jenkins中的插件介绍中有相关策略介绍(https://plugins.jenkins.io/pretested-integration/)

# 4. Share: 慢下来的能力

我是在2014年的时候知道`Python`这门编程语言的。当时人工智能还处在爆发的前夕，远远没有到现在万众瞩目，言必称：AI、机器学习的程度。因此`Python`这门语言还是处在推荐的人很多，讲了许多优秀的地方，但是暂时没有看到一个杀手级应用的状况。

毫无疑问我们生活在一个快时代，这就搞的我们做什么事情都显得很急躁