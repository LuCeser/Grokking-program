# 2020 M6W4 ARTS

# 1. Algorithm

## 1.1 LeetCode 70.爬楼梯

上周本来准备把和找零钱相关的两道爬楼梯的题目做了，但实在没找出时间来，本周做一下。

看一下题干：

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。
>
> 示例 1：
> ```
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> ```
> 示例 2：
> ```
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶
> ```
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/climbing-stairs
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

首先要注意一点，爬楼梯的解法中不同的顺序视为不同的方法，比如`1 + 2`和`2 + 1`是两种不同的解法，一开始没有意识到，思维走入了误区。

先说我是怎么想的：

先用笨办法，把简单的几种情况列出来

```
n = 1
1. 1

n = 2
1. 1 + 1
2. 2

n = 3
1. 1 + 1 + 1
2. 1 + 2
3. 2 + 1

n = 4
1. 1 + 1 + 1 +1
2. 1 + 1 + 2
3. 1 + 2 + 1
4. 2 + 2
5. 2 + 1 + 1

n = 5
1. 1 + 1 + 1 + 1 + 1
2. 1 + 1 + 1 + 2
3. 1 + 2 + 1 + 1
4. 2 + 1 + 1 + 1
5. 1 + 2 + 2
6. 2 + 2 + 1
7. 2 + 1 + 2
```

列n为1~5的情况，不负责任的猜想，n 的解法就是` (n - 1) + (n - 2)`，终止条件就是`n = 1`。

那么直接能够想到的就是利用递归：

```python
class Solution:
    def climbStairs(self, n: int) -> int:
      	# 递归必备，设定终止条件
        # 当n<=1或n<3时说明已经递归到头了
        if n <= 1:
            return 1
        if n < 3:
            return n
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)
 
```

我认为这种做法是没有问题的，但提交结果告诉我运行超时了，也就是说递归在这个题中效率太差，看了其他人的题解，可以采用尾递归的方式（mark一下，后续待了解）

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        first = 1
        second = 2
        sum = 0
        while(n > 2):
            sum = first + second
            first = second
            second = sum
            n = n - 1
        return sum

```



# 2. Review: 

# 3. Tip:  

# 4. Share: 
