# 2020 M6W4 ARTS

# 1. Algorithm

## 1.1 LeetCode 70.爬楼梯

上周本来准备把和找零钱相关的两道爬楼梯的题目做了，但实在没找出时间来，本周做一下。

看一下题干：

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。
>
> 示例 1：
> ```
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> ```
> 示例 2：
> ```
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶
> ```
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/climbing-stairs
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

首先要注意一点，爬楼梯的解法中不同的顺序视为不同的方法，比如`1 + 2`和`2 + 1`是两种不同的解法，一开始没有意识到，思维走入了误区。

先说我是怎么想的：

先用笨办法，把简单的几种情况列出来

```
n = 1
1. 1

n = 2
1. 1 + 1
2. 2

n = 3
1. 1 + 1 + 1
2. 1 + 2
3. 2 + 1

n = 4
1. 1 + 1 + 1 +1
2. 1 + 1 + 2
3. 1 + 2 + 1
4. 2 + 2
5. 2 + 1 + 1

n = 5
1. 1 + 1 + 1 + 1 + 1
2. 1 + 1 + 1 + 2
3. 1 + 2 + 1 + 1
4. 2 + 1 + 1 + 1
5. 1 + 2 + 2
6. 2 + 2 + 1
7. 2 + 1 + 2
```

列n为1~5的情况，不负责任的猜想，n 的解法就是` (n - 1) + (n - 2)`，终止条件就是`n = 1`。

那么直接能够想到的就是利用递归：

```python
class Solution:
    def climbStairs(self, n: int) -> int:
      	# 递归必备，设定终止条件
        # 当n<=1或n<3时说明已经递归到头了
        if n <= 1:
            return 1
        if n < 3:
            return n
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)
 
```

我认为这种做法是没有问题的，但提交结果告诉我运行超时了，也就是说递归在这个题中效率太差，看了其他人的题解，可以采用尾递归的方式（mark一下，后续待了解）

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        first = 1
        second = 2
        sum = 0
        while(n > 2):
            sum = first + second
            first = second
            second = sum
            n = n - 1
        return sum

```



# 2. Review: [Open Source Benefits to Innovation and Organizational Agility](https://www.infoq.com/news/2019/03/open-source-benefits/)

使用开源软件的理由  + 投入开源世界的理由：

1. 可以定制化软件，以便更符合自己的需求；
2. 允许快速试错。相比较于商业软件的巨大投入，可能在使用过程中发现不在适应当前的业务了，因为前期巨大投入的缘故，团队不会倾向于找一个更加合适的替代品；
3. 开源软件也是一种有效的构建软件方式，意味着你拥有全球各地的开发者协助你构建更高质量的软件，而且也可以防止做重复造轮子的事。

# 3. Tip:  Zookeeper在Java中的使用

https://www.throwable.club/2018/12/16/zookeeper-curator-usage/

# 4. Share: 组织你的知识

我浏览博客、技术社区、看书时，往往发现不知道该把那些知识放在哪里，比如数据库的知识要放在数据库的分类中么？那么具体到`mariadb`、`mysql`、`sqlserver`是否需要分到更下一级目录呢？不过不分多级目录的话以后查找起来是否会很麻烦？

通过类别来划分的话其实还有一个问题，比如说很多概念之间是有交叉的，比如说分布式是属于架构么？微服务是属于架构么？有一篇文章即讲微服务又讲分布式的到底是应该分类到分布式还是微服务？

上面这个例子可能不是很恰当，但我想谈论的话题是确定的：这种分类方式对于组织知识来说不够直接，与我们大脑中的模式不匹配。现在我采用更加面向专题的模式来组织收藏。

比如，现在开发过程中应用到了Zookeeper与分布式的知识，我就新建一个收藏夹，把Zookeeper、分布式有关的博客、帖子、笔记统统放入收藏夹中。这样我的收藏就是面向应用的，而不是把Zookeeper，分布式的知识割裂开来。而且这些收藏在下一个专题中也是可以别继续引用的。

这就是我的想法，知识需要连接起来，相关联的知识通过一个主题连接而不是分门别类的把他们割裂开来。